import { describe, it, expect, vi, beforeEach } from 'vitest'
import { reason, classifyIntent } from '~/services/agent.server'
import { generateText } from 'ai'

// Mock the AI SDK and provider makers
vi.mock('ai', () => ({
  generateText: vi.fn(),
}))

vi.mock('@ai-sdk/openai', () => ({
  createOpenAI: vi.fn(() => (model: string) => ({ id: 'mock-openai', model })),
}))
vi.mock('@openrouter/ai-sdk-provider', () => ({
  createOpenRouter: vi.fn(() => (model: string) => ({ id: 'mock-openrouter', model })),
}))

// Mock skills loader to simplify
vi.mock('~/services/skills.server', () => ({
  loadSkillMetadata: vi.fn(() => []),
  loadSkillInstructions: vi.fn(() => null),
  formatSkillSummary: vi.fn(() => 'mock-skill-summary'),
}))

describe('Agent Server Service', () => {
  beforeEach(() => {
    vi.resetAllMocks()
  })

  describe('reason', () => {
    it('should return a parsed JSON action generated by the LLM', async () => {
      // Mock LLM returning valid JSON
      vi.mocked(generateText).mockResolvedValue({
        text: '{"action": "navigate", "url": "https://example.com", "reasoning": "testing"}',
      } as any)

      const action = await reason('mock-key', 'mock-model', [], '', 'mock-dom', [], 'openai')

      expect(generateText).toHaveBeenCalled()
      expect(action).toMatchObject({
        action: 'navigate',
        url: 'https://example.com',
      })
    })

    it('should handle error gracefully and return an error action if parsing fails', async () => {
      // Mock LLM returning completely invalid text
      vi.mocked(generateText).mockResolvedValue({
        text: "I am an AI, I don't follow JSON rules.",
      } as any)

      const action = await reason('mock-key', 'mock-model', [], '', 'mock-dom', [], 'openai')

      expect(action.action).toBe('error')
      expect(action.reasoning).toContain('LLM returned invalid output')
    })

    it('should return a 401 error action if AI SDK throws a 401 unauth error', async () => {
      // Mock SDK throw
      vi.mocked(generateText).mockRejectedValue({ status: 401, message: 'Unauthorized' })

      const action = await reason('key', 'model', [], '', '', [])
      expect(action.action).toBe('error')
      if (action.action === 'error') {
        expect(action.message).toContain('Invalid API key')
      }
    })
  })

  describe('classifyIntent', () => {
    it('should return parsed intent json', async () => {
      vi.mocked(generateText).mockResolvedValue({
        text: '{"action": "use_skill", "skill_name": "standard-login", "reasoning": "user wants to login"}',
      } as any)

      const intent = await classifyIntent('key', 'model', 'Please login', 'openai')
      expect(intent.action).toBe('use_skill')
      expect(intent.skill_name).toBe('standard-login')
    })

    it('should default to proceed if the model hallucinates non-JSON', async () => {
      vi.mocked(generateText).mockResolvedValue({
        text: 'Sure, I can help you with that!',
      } as any)

      const intent = await classifyIntent('key', 'model', 'Please login', 'openai')
      expect(intent.action).toBe('proceed')
      expect(intent.reasoning).toContain('Could not parse')
    })

    it('should normalize plain website login requests to standard-login', async () => {
      vi.mocked(generateText).mockResolvedValue({
        text: '{"action":"refuse","reasoning":"No skill exists for logging into third-party services like LeetCode."}',
      } as any)

      const intent = await classifyIntent('key', 'model', 'go to leetcode.com and login', 'openai')

      expect(intent.action).toBe('use_skill')
      expect(intent.skill_name).toBe('standard-login')
    })
  })
})
